package service

import (
	"encoding/json"
	"fmt"
	"net/http"
	"testing"

	"github.com/labstack/echo/v4"

	"github.com/deepmap/oapi-codegen/pkg/middleware"
	"github.com/deepmap/oapi-codegen/pkg/testutil"

	"github.com/billyross/boilerplate-api-service/pkg/api"
)

func TestPetStore(t *testing.T) {
	var err error
	// Here, we Initialize echo
	e := echo.New()

	// Now, we create our empty pet store
	store := NewPetStore()

	// Get the swagger description of our API
	swagger, err := api.GetSwagger()
	if err != nil {
		t.Log("failed to load openapi description")
		t.Fail()
	}

	// Clear out the servers array in the swagger spec, that skips validating
	// that server names match. We don't know how this thing will be run.
	swagger.Servers = nil

	// Validate requests against the OpenAPI spec
	e.Use(middleware.OapiRequestValidator(swagger))

	// We register the autogenerated boilerplate and bind our PetStore to this
	// echo router.
	api.RegisterHandlers(e, store)

	t.Run("Add pet", func(t *testing.T) {
		tag := "TagOfSpot"
		newPet := api.NewPet{
			Name: "Spot",
			Tag:  &tag,
		}

		rr := testutil.NewRequest().Post("/pets").WithJsonBody(newPet).GoWithHTTPHandler(t, e).Recorder
		if http.StatusCreated != rr.Code {
			t.Log(fmt.Sprintf("wrong status: %v != %v", http.StatusCreated, rr.Code))
			t.Fail()
		}

		var resultPet api.Pet
		err = json.NewDecoder(rr.Body).Decode(&resultPet)
		if err != nil {
			t.Log("error unmarshaling response")
			t.Fail()
		}
		if newPet.Name != resultPet.Name {
			t.Log(fmt.Sprintf("wrong pet name: %v != %v", newPet.Name, resultPet.Name))
			t.Fail()
		}
	})

	t.Run("Find pet by ID", func(t *testing.T) {
		pet := api.Pet{
			Id: 100,
		}

		store.Pets[pet.Id] = pet
		rr := testutil.NewRequest().Get(fmt.Sprintf("/pets/%d", pet.Id)).WithAcceptJson().Go(t, e).Recorder
		var resultPet api.Pet
		err = json.NewDecoder(rr.Body).Decode(&resultPet)
		if err != nil {
			t.Log("error getting pet")
			t.Fail()
		}
		if pet != resultPet {
			t.Log(fmt.Sprintf("wrong pet: %+v != %+v", pet, resultPet))
			t.Fail()
		}
	})

	t.Run("Pet not found", func(t *testing.T) {
		rr := testutil.NewRequest().Get("/pets/27179095781").WithAcceptJson().Go(t, e).Recorder
		if http.StatusNotFound != rr.Code {
			t.Log(fmt.Sprintf("wrong status: %v != %v", http.StatusNotFound, rr.Code))
			t.Fail()
		}

		var petError api.Error
		err = json.NewDecoder(rr.Body).Decode(&petError)
		if err != nil {
			t.Log("error getting response")
			t.Fail()
		}
		if int32(http.StatusNotFound) != petError.Code {
			t.Log(fmt.Sprintf("wrong status: %v != %v", http.StatusNotFound, petError.Code))
			t.Fail()
		}
	})

	t.Run("List all pets", func(t *testing.T) {
		store.Pets = map[int64]api.Pet{
			1: {},
			2: {},
		}

		// Now, list all pets, we should have two
		rr := testutil.NewRequest().Get("/pets").WithAcceptJson().Go(t, e).Recorder
		if http.StatusOK != rr.Code {
			t.Log(fmt.Sprintf("wrong status: %v != %v", http.StatusOK, rr.Code))
			t.Fail()
		}

		var petList []api.Pet
		err = json.NewDecoder(rr.Body).Decode(&petList)
		if err != nil {
			t.Log("error getting response")
			t.Fail()
		}
		if len(petList) != 2 {
			t.Log(fmt.Sprintf("wrong pet length: %v != %v", 2, len(petList)))
			t.Fail()
		}
	})

	t.Run("Filter pets by tag", func(t *testing.T) {
		tag := "TagOfFido"

		store.Pets = map[int64]api.Pet{
			1: {
				NewPet: api.NewPet{
					Tag: &tag,
				},
			},
			2: {},
		}

		// Filter pets by tag, we should have 1
		rr := testutil.NewRequest().Get("/pets?tags=TagOfFido").WithAcceptJson().Go(t, e).Recorder
		if http.StatusOK != rr.Code {
			t.Log(fmt.Sprintf("wrong status: %v != %v", http.StatusOK, rr.Code))
			t.Fail()
		}

		var petList []api.Pet
		err = json.NewDecoder(rr.Body).Decode(&petList)
		if err != nil {
			t.Log("error getting response")
			t.Fail()
		}
		if len(petList) != 1 {
			t.Log(fmt.Sprintf("wrong pet length: %v != %v", 1, len(petList)))
			t.Fail()
		}
	})

	t.Run("Filter pets by tag", func(t *testing.T) {
		store.Pets = map[int64]api.Pet{
			1: {},
			2: {},
		}

		// Filter pets by non existent tag, we should have 0
		rr := testutil.NewRequest().Get("/pets?tags=NotExists").WithAcceptJson().Go(t, e).Recorder
		if http.StatusOK != rr.Code {
			t.Log(fmt.Sprintf("wrong status: %v != %v", http.StatusOK, rr.Code))
			t.Fail()
		}

		var petList []api.Pet
		err = json.NewDecoder(rr.Body).Decode(&petList)
		if err != nil {
			t.Log("error getting response")
			t.Fail()
		}
		if len(petList) != 0 {
			t.Log(fmt.Sprintf("wrong pet length: %v != %v", 0, len(petList)))
			t.Fail()
		}
	})

	t.Run("Delete pets", func(t *testing.T) {
		store.Pets = map[int64]api.Pet{
			1: {},
			2: {},
		}

		// Let's delete non-existent pet
		rr := testutil.NewRequest().Delete("/pets/7").GoWithHTTPHandler(t, e).Recorder
		if http.StatusNotFound != rr.Code {
			t.Log(fmt.Sprintf("wrong status: %v != %v", http.StatusNotFound, rr.Code))
			t.Fail()
		}

		var petError api.Error
		err = json.NewDecoder(rr.Body).Decode(&petError)
		if err != nil {
			t.Log("error unmarshaling PetError")
			t.Fail()
		}
		if int32(http.StatusNotFound) != petError.Code {
			t.Log(fmt.Sprintf("wrong status: %v != %v", http.StatusNotFound, petError.Code))
			t.Fail()
		}

		// Now, delete both real pets
		rr = testutil.NewRequest().Delete("/pets/1").GoWithHTTPHandler(t, e).Recorder
		if http.StatusNoContent != rr.Code {
			t.Log(fmt.Sprintf("wrong status: %v != %v", http.StatusNoContent, rr.Code))
			t.Fail()
		}

		rr = testutil.NewRequest().Delete("/pets/2").GoWithHTTPHandler(t, e).Recorder
		if http.StatusNoContent != rr.Code {
			t.Log(fmt.Sprintf("wrong status: %v != %v", http.StatusNoContent, rr.Code))
			t.Fail()
		}

		// Should have no pets left.
		var petList []api.Pet
		rr = testutil.NewRequest().Get("/pets").WithAcceptJson().Go(t, e).Recorder
		if http.StatusOK != rr.Code {
			t.Log(fmt.Sprintf("wrong status: %v != %v", http.StatusOK, rr.Code))
			t.Fail()
		}
		err = json.NewDecoder(rr.Body).Decode(&petList)
		if err != nil {
			t.Log("error getting response")
			t.Fail()
		}
		if len(petList) != 0 {
			t.Log(fmt.Sprintf("wrong pet length: %v != %v", 0, len(petList)))
			t.Fail()
		}
	})
}
